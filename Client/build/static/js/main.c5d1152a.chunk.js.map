{"version":3,"sources":["shared/constants/index.ts","services/TokenService.ts","services/HttpService.ts","api/auth/index.ts","store/auth/actions.ts","store/auth/index.ts","store/index.ts","App.tsx","index.tsx"],"names":["TOKEN_NAME","tokenService","_token","savedToken","localStorage","getItem","parsedToken","JSON","parse","Math","floor","Date","expires_in","this","removeToken","access_token","tokenData","rememberToken","setItem","stringify","removeItem","instance","axios","create","baseURL","process","interceptors","request","use","handleToken","response","handleSuccess","handleError","config","token","getToken","headers","Authorization","error","status","console","warn","data","Promise","reject","get","login","post","put","delete","payload","email","password","params","fetchLogin","createAsyncThunk","a","rememberMe","initialState","loadingFlags","isAuthorized","Boolean","authSlice","createSlice","name","reducers","logout","state","extraReducers","builder","addCase","pending","typePrefix","fulfilled","setToken","rejected","_","log","actions","authReducer","reducer","store","configureStore","auth","useSelector","createSelectorHook","App","dispatch","useAppDispatch","className","onClick","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.c5d1152a.chunk.js","sourcesContent":["const { REACT_APP_BACKEND_URL } = process.env;\r\n\r\nexport const TOKEN_NAME = 'polyclinictoken';\r\n\r\nexport const BASE_URL = REACT_APP_BACKEND_URL;\r\n","import { TOKEN_NAME } from 'shared/constants';\r\nimport { Token } from 'api/auth/types';\r\n\r\nclass TokenService {\r\n    private _token: Token | null | undefined;\r\n\r\n    constructor() {\r\n        const savedToken = localStorage.getItem(TOKEN_NAME);\r\n\r\n        if (savedToken) {\r\n            const parsedToken: Token = JSON.parse(savedToken);\r\n\r\n            if (Math.floor(+new Date() / 1000) > parsedToken.expires_in) {\r\n                this.removeToken();\r\n            } else {\r\n                this._token = parsedToken;\r\n            }\r\n        } else {\r\n            this._token = null;\r\n        }\r\n    }\r\n\r\n    public getToken(): string | null {\r\n        if (this._token) {\r\n            return this._token.access_token;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public setToken(tokenData: Token, rememberToken: boolean): void {\r\n        tokenData.expires_in = Math.floor(+new Date() / 1000) + tokenData.expires_in;\r\n\r\n        if (rememberToken) {\r\n            localStorage.setItem(TOKEN_NAME, JSON.stringify(tokenData));\r\n        }\r\n\r\n        this._token = tokenData;\r\n    }\r\n\r\n    public removeToken(): void {\r\n        localStorage.removeItem(TOKEN_NAME);\r\n        this._token = null;\r\n    }\r\n}\r\n\r\nexport const tokenService = new TokenService();\r\n","import axios, { AxiosInstance, AxiosResponse, AxiosError, AxiosRequestConfig } from 'axios';\r\nimport { BASE_URL } from 'shared/constants';\r\n// import { paths } from 'routes/paths';\r\n// import { history } from 'lib/history';\r\nimport { tokenService } from './TokenService';\r\n\r\nclass HttpService {\r\n    public instance: AxiosInstance;\r\n\r\n    constructor() {\r\n        const instance = axios.create({\r\n            baseURL: BASE_URL,\r\n        });\r\n\r\n        // setting the token if it exists\r\n        instance.interceptors.request.use(this.handleToken);\r\n        // processing request\r\n        instance.interceptors.response.use(this.handleSuccess, this.handleError);\r\n\r\n        this.instance = instance;\r\n    }\r\n\r\n    private handleToken(config: AxiosRequestConfig) {\r\n        const token = tokenService.getToken();\r\n\r\n        if (token) {\r\n            config.headers.Authorization = `Bearer ${token}`;\r\n        }\r\n\r\n        return config;\r\n    }\r\n\r\n    private handleSuccess(response: AxiosResponse) {\r\n        return response;\r\n    }\r\n\r\n    private handleError(error: AxiosError): Promise<AxiosResponse> {\r\n        if (error.response && error.response.status) {\r\n            switch (error.response.status) {\r\n                // case 401:\r\n                //     tokenService.removeToken();\r\n                //     history.push(paths.LOGIN);\r\n                //     break;\r\n                // case 403:\r\n                // case 500:\r\n                //     history.push(paths.ERROR);\r\n                //     break;\r\n                default:\r\n                    console.warn('Error: ', error.response.data);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return Promise.reject(error.response);\r\n    }\r\n}\r\n\r\nconst { instance } = new HttpService();\r\n\r\nexport const { get, post, put, delete: del } = instance;\r\n","import { get } from 'services/HttpService';\r\nimport { RequestParams } from 'api/types';\r\nimport { LoginPayload, Token } from './types';\r\n\r\nexport const login = ({ payload: { email, password } }: RequestParams<LoginPayload>) =>\r\n    get<Token>('/api/User/token', {\r\n        params: {\r\n            email,\r\n            password,\r\n        },\r\n    });\r\n","import { createAsyncThunk } from '@reduxjs/toolkit';\r\nimport { login } from 'api/auth';\r\nimport { LoginPayload } from 'api/auth/types';\r\n\r\nexport const fetchLogin = createAsyncThunk(\r\n    'auth/fetchLogin',\r\n    async ({ email, password, rememberMe }: LoginPayload & { rememberMe: boolean }) => {\r\n        const { data: token } = await login({ payload: { email, password } });\r\n\r\n        return { token, rememberMe };\r\n    }\r\n);\r\n","import { createSlice } from '@reduxjs/toolkit';\r\nimport { AuthStore } from './types';\r\nimport { tokenService } from 'services/TokenService';\r\nimport { fetchLogin } from './actions';\r\n\r\nconst initialState: AuthStore = {\r\n    loadingFlags: {},\r\n    isAuthorized: Boolean(tokenService.getToken()),\r\n};\r\n\r\nexport const authSlice = createSlice({\r\n    name: 'auth',\r\n    initialState,\r\n    reducers: {\r\n        logout: (state) => {\r\n            state.isAuthorized = false;\r\n\r\n            tokenService.removeToken();\r\n        },\r\n    },\r\n    extraReducers: (builder) => {\r\n        builder.addCase(fetchLogin.pending, (state) => {\r\n            state.loadingFlags[fetchLogin.typePrefix] = true;\r\n        });\r\n        builder.addCase(fetchLogin.fulfilled, (state, { payload: { token, rememberMe } }) => {\r\n            state.isAuthorized = true;\r\n            state.loadingFlags[fetchLogin.typePrefix] = false;\r\n\r\n            tokenService.setToken(token, rememberMe);\r\n        });\r\n        builder.addCase(fetchLogin.rejected, (_, { payload }) => {\r\n            console.log(payload);\r\n        });\r\n    },\r\n});\r\n\r\nexport const { logout } = authSlice.actions;\r\n\r\nexport const authReducer = authSlice.reducer;\r\n","import { configureStore } from '@reduxjs/toolkit';\r\nimport { createSelectorHook, useDispatch as useAppDispatch } from 'react-redux';\r\nimport { authReducer } from './auth';\r\n\r\nexport const store = configureStore({\r\n    reducer: {\r\n        auth: authReducer,\r\n        // app: appReducer,\r\n        // users: usersReducer,\r\n        // auth: authReducer,\r\n        // results: resultsReducer,\r\n        // farms: farmsReducer,\r\n        // companies: companiesReducer,\r\n        // backgrounds: backgroundsReducer,\r\n        // complexes: complexesReducer,\r\n        // postingSessions: postingSessionsReducer,\r\n    },\r\n    // middleware: [\r\n    //     ...getDefaultMiddleware({\r\n    //         immutableCheck: false,\r\n    //         serializableCheck: false,\r\n    //     }),\r\n    // ],\r\n});\r\n\r\nexport type RootState = ReturnType<typeof store.getState>;\r\n\r\nexport type AppDispatch = typeof store.dispatch;\r\nexport const useDispatch = () => useAppDispatch<AppDispatch>();\r\n\r\nexport const useSelector = createSelectorHook<RootState>();\r\n","import './App.scss';\nimport { useDispatch, useSelector } from 'store';\nimport { logout } from 'store/auth';\nimport { fetchLogin } from 'store/auth/actions';\n\nexport const App = () => {\n    const dispatch = useDispatch();\n\n    const { isAuthorized, loadingFlags } = useSelector((state) => ({\n        isAuthorized: state.auth.isAuthorized,\n        loadingFlags: state.auth.loadingFlags,\n    }));\n\n    return (\n        <div className=\"App\">\n            {loadingFlags[fetchLogin.typePrefix] && <span>Loading...</span>}\n\n            {isAuthorized ? (\n                <button\n                    onClick={() => {\n                        dispatch(logout());\n                    }}\n                >\n                    Log out\n                </button>\n            ) : (\n                <button\n                    onClick={() => {\n                        dispatch(\n                            fetchLogin({\n                                email: 'artem.sdobnikov@nure.ua',\n                                password: 'Qwerty12345!',\n                                rememberMe: true,\n                            })\n                        );\n                    }}\n                >\n                    Log in\n                </button>\n            )}\n        </div>\n    );\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport { store } from 'store';\nimport { App } from './App';\n// import reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>,\n    document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n// reportWebVitals();\n"],"sourceRoot":""}